pub const SLEDGEHAMMER_JS: &str = "let m,p,ls,d,t,op,i,e,z,metaflags;\n            const namespace = [];\n                    let namespace_cache_hit, namespace_cache_idx;\n                    function get_namespace() {\n                        namespace_cache_idx = u8buf[u8bufp++];\n                        if(namespace_cache_idx & 128){\n                            namespace_cache_hit=s.substring(sp,sp+=u8buf[u8bufp++]);\n                            namespace[namespace_cache_idx&4294967167]=namespace_cache_hit;\n                            return namespace_cache_hit;\n                        }\n                        else{\n                            return namespace[namespace_cache_idx&4294967167];\n                        }\n                    }let u8buf,u8bufp;const attr = [];\n                    let attr_cache_hit, attr_cache_idx;\n                    function get_attr() {\n                        attr_cache_idx = u8buf[u8bufp++];\n                        if(attr_cache_idx & 128){\n                            attr_cache_hit=s.substring(sp,sp+=u8buf[u8bufp++]);\n                            attr[attr_cache_idx&4294967167]=attr_cache_hit;\n                            return attr_cache_hit;\n                        }\n                        else{\n                            return attr[attr_cache_idx&4294967167];\n                        }\n                    }const evt = [];\n                    let evt_cache_hit, evt_cache_idx;\n                    function get_evt() {\n                        evt_cache_idx = u8buf[u8bufp++];\n                        if(evt_cache_idx & 128){\n                            evt_cache_hit=s.substring(sp,sp+=u8buf[u8bufp++]);\n                            evt[evt_cache_idx&4294967167]=evt_cache_hit;\n                            return evt_cache_hit;\n                        }\n                        else{\n                            return evt[evt_cache_idx&4294967167];\n                        }\n                    }const el = [];\n                    let el_cache_hit, el_cache_idx;\n                    function get_el() {\n                        el_cache_idx = u8buf[u8bufp++];\n                        if(el_cache_idx & 128){\n                            el_cache_hit=s.substring(sp,sp+=u8buf[u8bufp++]);\n                            el[el_cache_idx&4294967167]=el_cache_hit;\n                            return el_cache_hit;\n                        }\n                        else{\n                            return el[el_cache_idx&4294967167];\n                        }\n                    }let u32buf,u32bufp;let s = \"\";let lsp,sp,sl; let c = new TextDecoder();let u16buf,u16bufp;const ns_cache = [];\n                    let ns_cache_cache_hit, ns_cache_cache_idx;\n                    function get_ns_cache() {\n                        ns_cache_cache_idx = u8buf[u8bufp++];\n                        if(ns_cache_cache_idx & 128){\n                            ns_cache_cache_hit=s.substring(sp,sp+=u8buf[u8bufp++]);\n                            ns_cache[ns_cache_cache_idx&4294967167]=ns_cache_cache_hit;\n                            return ns_cache_cache_hit;\n                        }\n                        else{\n                            return ns_cache[ns_cache_cache_idx&4294967167];\n                        }\n                    }\n            let field,ptr,array,ns,id,value,len,event,many,bubbles,event_name;\n            export  function create(r){\n                d=r;\n            }\n            export  function update_memory(b){\n                m=new DataView(b.buffer)\n            }\n            export  function run(){\n                metaflags=m.getUint32(d,true);\n                if((metaflags>>>6)&1){\n                    ls=m.getUint32(d+6*4,true);\n                }\n                p=ls;\n                if ((metaflags>>>5)&1){\n                t = m.getUint32(d+5*4,true);\n                u8buf=new Uint8Array(m.buffer,t,((m.buffer.byteLength-t)-(m.buffer.byteLength-t)%1)/1);\n            }\n            u8bufp=0;if ((metaflags>>>3)&1){\n                t = m.getUint32(d+3*4,true);\n                u32buf=new Uint32Array(m.buffer,t,((m.buffer.byteLength-t)-(m.buffer.byteLength-t)%4)/4);\n            }\n            u32bufp=0;if (metaflags&1){\n                lsp = m.getUint32(d+1*4,true);\n            }\n            if ((metaflags>>>2)&1) {\n                sl = m.getUint32(d+2*4,true);\n                if ((metaflags>>>1)&1) {\n                    sp = lsp;\n                    s = \"\";\n                    e = sp + ((sl / 4) | 0) * 4;\n                    while (sp < e) {\n                        t = m.getUint32(sp, true);\n                        s += String.fromCharCode(\n                            t & 255,\n                            (t & 65280) >> 8,\n                            (t & 16711680) >> 16,\n                            t >> 24\n                        );\n                        sp += 4;\n                    }\n                    while (sp < lsp + sl) {\n                        s += String.fromCharCode(m.getUint8(sp++));\n                    }\n                } else {\n                    s = c.decode(new DataView(m.buffer, lsp, sl));\n                }\n            }\n            sp=0;if ((metaflags>>>4)&1){\n                t = m.getUint32(d+4*4,true);\n                u16buf=new Uint16Array(m.buffer,t,((m.buffer.byteLength-t)-(m.buffer.byteLength-t)%2)/2);\n            }\n            u16bufp=0;\n                for(;;){\n                    op=m.getUint32(p,true);\n                    p+=4;\n                    z=0;\n                    while(z++<4){\n                        switch(op&255){\n                            case 0:{AppendChildren(root, stack.length-1);}break;case 1:{stack.push(nodes[u32buf[u32bufp++]]);}break;case 2:{AppendChildren(u32buf[u32bufp++], u16buf[u16bufp++]);}break;case 3:{stack.pop();}break;case 4:{root = nodes[u32buf[u32bufp++]]; els = stack.splice(stack.length-u16buf[u16bufp++]); if (root.listening) { listeners.removeAllNonBubbling(root); } root.replaceWith(...els);}break;case 5:{nodes[u32buf[u32bufp++]].after(...stack.splice(stack.length-u16buf[u16bufp++]));}break;case 6:{nodes[u32buf[u32bufp++]].before(...stack.splice(stack.length-u16buf[u16bufp++]));}break;case 7:{node = nodes[u32buf[u32bufp++]]; if (node !== undefined) { if (node.listening) { listeners.removeAllNonBubbling(node); } node.remove(); }}break;case 8:{stack.push(document.createTextNode(s.substring(sp,sp+=u32buf[u32bufp++])));}break;case 9:{node = document.createTextNode(s.substring(sp,sp+=u32buf[u32bufp++])); nodes[u32buf[u32bufp++]] = node; stack.push(node);}break;case 10:{node = document.createElement('pre'); node.hidden = true; stack.push(node); nodes[u32buf[u32bufp++]] = node;}break;case 11:event_name=get_evt();id=u32buf[u32bufp++];bubbles=u8buf[u8bufp++];node = nodes[id]; if(node.listening){node.listening += 1;}else{node.listening = 1;} node.setAttribute('data-dioxus-id', `${id}`); listeners.create(event_name, node, bubbles);break;case 12:{node = nodes[u32buf[u32bufp++]]; node.listening -= 1; node.removeAttribute('data-dioxus-id'); listeners.remove(node, get_evt(), u8buf[u8bufp++]);}break;case 13:{nodes[u32buf[u32bufp++]].textContent = s.substring(sp,sp+=u32buf[u32bufp++]);}break;case 14:{node = nodes[u32buf[u32bufp++]]; setAttributeInner(node, get_attr(), s.substring(sp,sp+=u32buf[u32bufp++]), get_ns_cache());}break;case 15:id=u32buf[u32bufp++];field=get_attr();ns=get_ns_cache();{\n                node = nodes[id];\n                if (!ns) {\n                    switch (field) {\n                        case \"value\":\n                            node.value = \"\";\n                            break;\n                        case \"checked\":\n                            node.checked = false;\n                            break;\n                        case \"selected\":\n                            node.selected = false;\n                            break;\n                        case \"dangerous_inner_html\":\n                            node.innerHTML = \"\";\n                            break;\n                        default:\n                            node.removeAttribute(field);\n                            break;\n                    }\n                } else if (ns == \"style\") {\n                    node.style.removeProperty(name);\n                } else {\n                    node.removeAttributeNS(ns, field);\n                }\n            }break;case 16:{nodes[u32buf[u32bufp++]] = LoadChild(u32buf[u32bufp++], u8buf[u8bufp++]);}break;case 17:ptr=u32buf[u32bufp++];len=u8buf[u8bufp++];value=s.substring(sp,sp+=u32buf[u32bufp++]);id=u32buf[u32bufp++];{\n                node = LoadChild(ptr, len);\n                if (node.nodeType == Node.TEXT_NODE) {\n                    node.textContent = value;\n                } else {\n                    let text = document.createTextNode(value);\n                    node.replaceWith(text);\n                    node = text;\n                }\n                nodes[id] = node;\n            }break;case 18:{els = stack.splice(stack.length - u16buf[u16bufp++]); node = LoadChild(u32buf[u32bufp++], u8buf[u8bufp++]); node.replaceWith(...els);}break;case 19:{node = templates[u16buf[u16bufp++]][u16buf[u16bufp++]].cloneNode(true); nodes[u32buf[u32bufp++]] = node; stack.push(node);}break;case 20:many=u16buf[u16bufp++];{\n            root = stack[stack.length-many-1];\n            els = stack.splice(stack.length-many);\n            for (k = 0; k < many; k++) {\n                root.appendChild(els[k]);\n            }\n        }break;case 21:{setAttributeInner(stack[stack.length-1], get_attr(), s.substring(sp,sp+=u32buf[u32bufp++]), get_ns_cache());}break;case 22:{node = document.createElement('pre'); node.hidden = true; stack.push(node);}break;case 23:{stack.push(document.createElementNS(get_namespace(), get_el()))}break;case 24:{stack.push(document.createElement(get_el()))}break;case 25:{templates[u16buf[u16bufp++]] = stack.splice(stack.length-u16buf[u16bufp++]);}break;case 26:event=get_evt();id=u32buf[u32bufp++];bubbles=u8buf[u8bufp++];\n        bubbles = bubbles == 1;\n        node = nodes[id];\n        if(node.listening){\n            node.listening += 1;\n        } else {\n            node.listening = 1;\n        }\n        node.setAttribute('data-dioxus-id', `${id}`);\n        const event_name = event;\n\n        // if this is a mounted listener, we send the event immediately\n        if (event_name === \"mounted\") {\n            window.ipc.postMessage(\n                window.interpreter.serializeIpcMessage(\"user_event\", {\n                    name: event_name,\n                    element: id,\n                    data: null,\n                    bubbles,\n                })\n            );\n        } else {\n            listeners.create(event_name, node, bubbles, (event) => {\n                handler(event, event_name, bubbles, config);\n            });\n        }break;case 27:{nodes[u32buf[u32bufp++]] = LoadChild((()=>{e=u8bufp+u32buf[u32bufp++];const final_array = u8buf.slice(u8bufp,e);u8bufp=e;return final_array;})());}break;case 28:array=(()=>{e=u8bufp+u32buf[u32bufp++];const final_array = u8buf.slice(u8bufp,e);u8bufp=e;return final_array;})();value=s.substring(sp,sp+=u32buf[u32bufp++]);id=u32buf[u32bufp++];{\n            node = LoadChild(array);\n            if (node.nodeType == Node.TEXT_NODE) {\n                node.textContent = value;\n            } else {\n                let text = document.createTextNode(value);\n                node.replaceWith(text);\n                node = text;\n            }\n            nodes[id] = node;\n        }break;case 29:{els = stack.splice(stack.length - u16buf[u16bufp++]); node = LoadChild((()=>{e=u8bufp+u32buf[u32bufp++];const final_array = u8buf.slice(u8bufp,e);u8bufp=e;return final_array;})()); node.replaceWith(...els);}break;case 30:return true;\n                        }\n                        op>>>=8;\n                    }\n                }\n            }\n            export  function run_from_bytes(bytes){\n                d = 0;\n                update_memory(new Uint8Array(bytes))\n                run()\n            }"
